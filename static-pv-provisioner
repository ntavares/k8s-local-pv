#!/bin/bash

#
# Note: if you change HOSTROOTMOUNT variable, you'll have to update the volume's path in the daemonset.yaml
#
HOSTROOTMOUNT=/host

function syntax() {
    >&2 echo "Syntax: $0 -A <add|remove|list-local> ..."
}

function get_ts() {
    TS=$(date +"%Y-%m-%d %H:%M:%S")
}

function prefixed() {
    get_ts
    echo "[$TS] [provisioner] "$*
}

function error() {
    >&2 prefixed "ERROR: "$*
}

function info() {
    >&2 prefixed "INFO: "$*
}

function debug() {
    if [ "$DEBUG" = "true" ] ; then
        >&2 prefixed "DEBUG: "$*
    fi
}

#
# Just in case we need to sanitize the LV name
#
function sanitize_lv_name() {
    _PVNAME="$1"
    echo "$XPVNAME"
}

#
# Units in K8s and LV use different syntax. See:
# https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#meaning-of-memory
# https://linux.die.net/man/8/lvcreate
#
function sanitize_lv_size() {
    _VOLSIZE="$1"
    units=$(echo "$_VOLSIZE" | sed 's,^[[:digit:]]\+,,g')
    value=$(echo "$_VOLSIZE" | sed 's,^\([[:digit:]]\+\).*$,\1,g')
    _SANITIZED=""
    case "$units" in
    Ti) _SANITIZED=T ;;
    Gi) _SANITIZED=G ;;
    Mi) _SANITIZED=M ;;
    Ki) _SANITIZED=M ;;
    esac
    echo $value$_SANITIZED
}

function sanitize_systemd_unit_filename() {
    local XMOUNTPATH="$1"
    echo $XMOUNTPATH | sed 's,-,\\x2d,g; s,/,-,g; s,^-,,g'
}

function defer_mount_systemd() {
    local XDEVFILE="$1"
    local XMOUNTPATH="$2"
    local XFSTYPE="$3"
    local XMOUNTOPTS="$4"

    local SDFILENAME=$(sanitize_systemd_unit_filename "$XMOUNTPATH")

    debug "defer_mount_systemd: Going to create: $HOSTROOTMOUNT/etc/systemd/system/${SDFILENAME}.mount"
    cat > "$HOSTROOTMOUNT/etc/systemd/system/${SDFILENAME}.mount" <<EOF
#
# This file is generated by Kubernetes portavita.net/k8s-local-pv provisioner
#
[Unit]
Description=Mount for Kubernetes PersistentVolume
Conflicts=umount.target

[Mount]
What=${XDEVFILE}
Where=${XMOUNTPATH}
Type=${XFSTYPE}
Options=${XMOUNTOPTS}

[Install]
WantedBy=multi-user.target

EOF

    [ "$DEBUG" = "true" ] && cat "$HOSTROOTMOUNT/etc/systemd/system/${SDFILENAME}.mount"

    info "defer_mount_systemd: Mounting on $XMOUNTPATH (via systemd)"
    run_cmd systemctl daemon-reload
    run_cmd systemctl start ${SDFILENAME}.mount
    run_cmd systemctl enable ${SDFILENAME}.mount
}


function defer_unmount_systemd() {
    local XMOUNTPATH="$1"

    local SDFILENAME=$(sanitize_systemd_unit_filename "$XMOUNTPATH")

    info "defer_unmount_systemd: Un-mounting $XMOUNTPATH (via systemd)"
    run_cmd systemctl stop ${SDFILENAME}.mount
    run_cmd systemctl disable ${SDFILENAME}.mount
    run_cmd systemctl daemon-reload

    debug "defer_mount_systemd: Removing $HOSTROOTMOUNT/etc/systemd/system/${SDFILENAME}.mount"
    rm -f "$HOSTROOTMOUNT/etc/systemd/system/${SDFILENAME}.mount"
}

function get_mount_path() {
    echo "$MOUNTBASEPATH/$XPVNAME"
}

function provisioner_add() {
    local XPVNAME="$1"
    local XVGNAME="$2"
    local XFSTYPE="$3"
    local XMOUNTOPTS="$4"
    local XVOLSIZE="$5"
    local XFSOPTS="$6"
    local XCRYPTSECRET="$7"

    if [ -n "$XCRYPTSECRET" ] ; then
        info "WARNING - Encryption was requested, but it's not supported (yet). Ignoring."
    fi

    XMOUNTPATH=$(get_mount_path)

    if [ -z "$(vgdisplay -s 2>/dev/null | cut -d '"' -f 2 | grep $XVGNAME)" ] ; then
        error "No VG found with name: $XVGNAME"
        exit 127
    fi

    _LVNAME=$(sanitize_lv_name "$XPVNAME")
    DETECT_LV=$(detect_lv "$XVGNAME" "$_LVNAME")
    if [ -n "$DETECT_LV" ] ; then
        info "Found an LV already provisioned with name '$DETECT_LV'. Skipping lvcreate"
    else
        LVSIZE=$(sanitize_lv_size "$XVOLSIZE")
        run_cmd lvcreate -W y -Z y --yes -n "$_LVNAME" -L "$LVSIZE" "$XVGNAME" # --addtag k8s-local-pv
    fi

    LV_DEV_NAME="/dev/$XVGNAME/$_LVNAME"

    DETECT_FSTYPE=$(run_cmd_ignore_rc blkid -o value -s TYPE "$LV_DEV_NAME")
    if [ "$DETECT_FSTYPE" = "$XFSTYPE" ] ; then
        info "Found filesystem of type '$DETECT_FSTYPE' already there. Skipping mkfs..."
    else
        if [ -n "$XFSOPTS" ] ; then
            run_cmd mkfs -t "$XFSTYPE" $XFSOPTS "$LV_DEV_NAME"
        else
            run_cmd mkfs -t "$XFSTYPE" "$LV_DEV_NAME"
        fi
    fi

    DETECT_MOUNT=$(detect_mount "$LV_DEV_NAME")
    if [ -n "$DETECT_MOUNT" ] ; then
        info "Found '$LV_DEV_NAME' already mounted on '$DETECT_MOUNT'"
    else
        defer_mount_systemd "$LV_DEV_NAME" "$XMOUNTPATH" "$XFSTYPE" "$XMOUNTOPTS"
    fi
}

function run_cmd_ignore_rc() {
    debug "[CMD] "$*
    if [ "$DRYRUN" != "true" ] ; then
        chroot $HOSTROOTMOUNT $*
    fi
}

function run_cmd() {
    run_cmd_ignore_rc $*
    if [ $? -ne 0 ] ; then
        error "Error executing: "$*
        exit 126
    fi
}

function detect_mount() {
    local XLV_DEV_NAME="$1"
    # The mount table refers to the devicemapper common path, which we don't have, so let's get it:
    LV_DM_NAME=$(run_cmd_ignore_rc dmsetup info "$XLV_DEV_NAME" | grep ^Name: | awk '{print $2}')

    run_cmd_ignore_rc grep "^/dev/mapper/${LV_DM_NAME}[[:space:]]" /proc/mounts | awk '{print $2;}'
}

function detect_lv() {
    local XVGNAME="$1"
    local XLVNAME="$2"
    lvdisplay -C 2>/dev/null | tail -n +2 | awk "\$2~/$XVGNAME/{print \$1}" | awk "/^$XLVNAME\$/"

}

function provisioner_remove() {
    XPVNAME="$1"
    XVGNAME="$2"

    XMOUNTPATH=$(get_mount_path)

    _LVNAME=$(sanitize_lv_name "$XPVNAME")
    LV_DEV_NAME="/dev/$XVGNAME/$_LVNAME"

    DETECT_MOUNT=$(detect_mount "$LV_DEV_NAME")
    if [ -z "$DETECT_MOUNT" ] ; then
        info "Did not find a mount on '$DETECT_MOUNT'. Skipping umount"
    else
        defer_unmount_systemd "$XMOUNTPATH"
    fi

    DETECT_LV=$(detect_lv "$XVGNAME" "$_LVNAME")
    if [ -z "$DETECT_LV" ] ; then
        info "Did not find an LV with name: $DETECT_LV. skipping lvremove"
    else
        # we could some shredding here.... but :-/
        run_cmd lvremove -f /dev/$XVGNAME/$_LVNAME
    fi

    DETECT_LV=$(run_cmd_ignore_rc find $MOUNTBASEPATH -maxdepth 1 -type d | grep $XMOUNTPATH)
    if [ -n "$DETECT_LV" ] ; then
        run_cmd "rmdir $XMOUNTPATH"
    fi

    info "Finished operations on mountpoint '$XMOUNTPATH'."
}

function provisioner_list_local() {
    info "Searching for local mountpoints, found:"
    run_cmd_ignore_rc find $MOUNTBASEPATH -maxdepth 1 -type d 2>/dev/null | sed "s,^$MOUNTBASEPATH,,g; /^$/ d; s,^/,,g;"
}


DEBUG="false"
CRYPTSECRET=""
DRYRUN="false"
MOUNTBASEPATH="/mnt/pv"
while getopts ":O:T:V:vA:P:N:E:S:F:" opt; do
  case $opt in
    A)
      ACTION="$OPTARG"
      debug "ACTION: $ACTION"
      ;;
    E)
      CRYPTSECRET="$OPTARG"
      debug "CRYPTSECRET: $CRYPTSECRET"
      ;;
    F)
      FSOPTS="$OPTARG"
      debug "FSOPTS: $FSOPTS"
      ;;
    N)
      PVNAME="$OPTARG"
      debug "PVNAME: $PVNAME"
      ;;
    O)
      MOUNTOPTS="$OPTARG"
      debug "MOUNTOPTS: $MOUNTOPTS"
      ;;
    P)
      MOUNTBASEPATH="$OPTARG"
      debug "MOUNTBASEPATH: $MOUNTBASEPATH"
      ;;
    S)
      VOLSIZE="$OPTARG"
      debug "VOLSIZE: $VOLSIZE"
      ;;
    T)
      FSTYPE="$OPTARG"
      debug "FSTYPE: $FSTYPE"
      ;;
    V)
      VGNAME="$OPTARG"
      debug "VGNAME: $VGNAME"
      ;;
    v)
      DEBUG="true"
      debug "DEBUG: $DEBUG"
      ;;
    ?)
      error "Invalid option: -$OPTARG"
      syntax
      exit 1
      ;;
    :)
      error "Option -$OPTARG requires an argument."
      syntax
      exit 1
      ;;
  esac
done

case "$ACTION" in
add)
    if [ -z "$PVNAME" -o -z "$MOUNTOPTS" -o -z "$FSTYPE" -o -z "$VGNAME" -o -z "$VOLSIZE" ] ; then
        error "Insufficient parameters."
        syntax
        exit 1
    fi
    provisioner_add "$PVNAME" "$VGNAME" "$FSTYPE" "$MOUNTOPTS" "$VOLSIZE" "$FSOPTS" "$CRYPTVOL"
    ;;
remove)
    if [ -z "$PVNAME" -o -z "$VGNAME" ] ; then
        error "Insufficient parameters."
        syntax
        exit 1
    fi
    provisioner_remove "$PVNAME" "$VGNAME"
    ;;
list-local)
    provisioner_list_local
    ;;
*)
    error "Invalid action: $ACTION. Aborting.."
    syntax
    exit 1
esac
